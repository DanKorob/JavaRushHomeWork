home02:
    ? Не решил
home03:
    ! С synchronized разобрался - методы sell и buy должны включать мютекс когда они вызываются.
    Но почему мапа allDrugs не volatile? Или почему не должна быть?
home04:
    ? StringBuilder - не синхронизирован, то бишь небезопасное поведение в мультипоточной среде.
home05:
    ! Ход мысли: любые операции в методе append проводились над локально придедшем параметром s.
    Тут не нужен synchronized.
    Метод appendThis проводит изменения в классе Solution, то бишь нужно дождаться изменений блокировкой.
    writeObject - должен быть синхронизирован (почему) ? - чтобы считать корректно (не вышло так, что
    к-во value не соответствует count)
    readObject - тут просто считываем, какое-то конкретно состояние (и не важно что пока мы считывали
    уже могло что-то поменяться)
    "Синхронизировать весь класс нужно только когда есть что-то статическое."
home06:
    ! Хорошая задача на понятие того, что именно синхронизируется (чтобы вернуть - убрать synchronized)
    Вся суть в блокировке по классу. но у мен я прошло при Solution.Person.class, а по идее необходимо
    по Solution.Iron.class. ?
home07:
    ! Просто добавил два synchronized. Больше сложностей с расшифровкой задания.
home10:
    Достаточно одного join(). а synchronized нужен из-за do..while, так как один вход в цикл
    произойдет полюбому.
bonus1:
    Проблемы возникли больше всего с форматированием даты.
